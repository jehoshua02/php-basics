# PHP Basics Part 4 - Classes and Objects, The Practical

### Introduction

PHP 5 and greater include a "complete object model".

- visibility
- abstract
- final classes and methods
- additional magic methods
- interfaces
- cloning
- typehinting

Objects are passed by reference, rather than copied into the variable.

### The Basics

Example:

```php
<?php
class SimpleClass
{
    // property declaration
    public $var = 'a default value';

    // method declaration
    public function displayVar() {
        echo $this->var;
    }
}
```

You've seen this before.
Variables tied to a class are called "properties".
Functions tied to a class are called "methods".
The psuedo-variable `$this` available on methods called in object context
Not in static context, with static operator `::` but with object operator `->`.

That's how you define a class, but to use the class, you use `new` keyword to create an instance.

Example:

```php
<?php
$instance = new SimpleClass();

// This can also be done with a variable:
$className = 'SimpleClass';
$instance = new $className(); // new SimpleClass()
```

Within the class, you could instantiate the class itself with `new static` or `new self`. Probably won't do that often though.

Access property like this: `$instance->someProperty`.
Call a method like this: `$instance->someMethod()`.

Classes inherit properties and methods from another class with `extends`:

```php
<?php
class ExtendClass extends SimpleClass
{
    // Redefine the parent method
    function displayVar()
    {
        echo "Extending class\n";
        parent::displayVar();
    }
}

$extended = new ExtendClass();
$extended->displayVar();
```

Get the fully qualified class name (includes the namespace) as a string with the `SimpleClass::class` syntax.

### Properties

Visibility - `public`, `protected`, `private` (covered later).

You can initialize a value, but value cannot depend on run time evaluation.

Non-static access: `$instance->someProperty`
Static access: `SimpleClass::$someProperty`

More about `static` later.

### Class Constants

Example:

```php
<?php
class MyClass
{
    public const CONSTANT = 'constant value';

    function showConstant() {
        echo  self::CONSTANT . "\n";
    }
}
```

Similar to properites, they have visibility, can be assigned simple values at compile time, but they don't start with `$` and they are cannot be assigned a new value.

### Autoloading Classes

Example:

```php
<?php
spl_autoload_register(function ($class_name) {
    include $class_name . '.php';
});

$obj  = new MyClass1();
$obj2 = new MyClass2();
```

Ultimately, this is how the autoloading script generated by Composer loads classes. We include that script at the top of our application.

### Constructors and Destructors

If you define `__construct` method on your class, it will be called when the class is instantiated with the `new` keyword. Any initialization that needs to be done when instantiating the object goes in this method.

You must call `parent::__construct()` in child class to execute parent class' `__construct` method. Child classes don't always have to override `__construct`, nor do parents always have a `__construct`, but if they do ... you have to call it explicitly. Same goes for any other method you override.

Classes don't have to have a `__construct` method.

If your class defines a `__destruct` method, it will be called when the object is destroyed, including when the php script exits.

### Visibility

Properties, methods and constants have visibility.

Example:

```php
<?php
/**
 * Define MyClass
 */
class MyClass
{
    public $public = 'Public';
    protected $protected = 'Protected';
    private $private = 'Private';

    function printHello()
    {
        echo $this->public;
        echo $this->protected;
        echo $this->private;
    }
}

$obj = new MyClass();
echo $obj->public; // Works
echo $obj->protected; // Fatal Error
echo $obj->private; // Fatal Error
$obj->printHello(); // Shows Public, Protected and Private
```

`public` properties are visible inside and outside the class.
`protected` properties are visible in any class in the inheritance tree, but not outside the class.
`private` properties are visible only in the class they are defined.

Default visibility is `public`, but you really should set visibility explicitly, typically `protected`, unless there's a valid use case for something else.

But did you know, if you're my type, you can touch my private members?

### Object Inheritance

You can make your code as complex as you want with inheritance!

Inheriting classes inherit all properties and methods from the parent class. Inheriting classes may override, or redefine properties and methods in the parent class.

But be careful to avoid unnecessary complexity. Abstract only when it seems like a good fit. If it makes the code more confusing and harder to maintain, it's not a good idea. Follow your intuition.

### Scope Resolution Operator (::)

Paamayim Nekudotayim.

It's just a double-colon, or the static operator.

It's how you access constants, and properties or methods declared with the `static` keyword.

Use this with `self`, `parent`, or `static` to access static members inside the class.

### Static Keyword

Declaring methods and properties with `static` makes them accessible without instantiating the class.

#### Static Methods

The `static` keyword does two things when placed on a method:

- Make the method accessible without instantiating the class.
- Block the use of `$this` within the method.

However, you can still call the method non-statically (`$instance->staticMethod()`). This is actually plays nice with Laravel's dependency injection, since instances are injected.

#### Static Properties

Static properties cannot be accessed via arrow operator. Only with Paamayim Nekudotayim.

### Class Abstraction

You can define a class as abstract with the `abstract` keyword.

This blocks the class from being instantiated directly. You have to instantiate through a child class.

Methods can be marked as abstract to require the child to implement them.

### Object Interfaces

Example:

```php
<?php

interface MyCoolInterface
{
    public function coolMethod($coolArg);
}
```

Interface describe what methods a class must implement without implementing them.

Use `implements` keyword to apply an interface to a class:

```php
<?php

class MyCoolClass implements MyCoolInterface
{
    // now the class must implement coolMethod($coolArg) or fatal error is thrown.
}
```

You can use interfaces for type hinting as well, to require an object that merely implements certain methods, without being too strict about the class.

### Traits

A bandaid for single-inheritance.

Use traits to share functionality across classes that do not or cannot extend a common parent.

Classes `use` traits. Classes can `use` multiple traits. The class inherits methods and properties from the trait.

If you ever need to figure out inheritance precedence, you need to rethink your purpose in life. But this might help: https://www.php.net/manual/en/language.oop5.traits.php

You can compose traits into other traits, again with the `use` keyword.

You can make your code as complex as you want with traits!
